<!-- MIT license, at the bottom of the page. -->

<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8"/>
        <link rel="stylesheet" href="TableauA.css"/>
        <style>
                h3 {
                       margin: 20px 10px 5px 50px;
               }
               span {
                       display:inline-block;
                       margin: 10px 20px;
               }
               button:hover{
                       background: #3cf;
                       border-radius: 5px;
               }
               .SmallButton {
                       width: 70px;
               }
               .MediumButton {
                       width: 90px;
               }
               .BigButton {
                       width: 110px;
               }
                #Controls {
                        margin: 20px 30px;
                }
                #Output {
                        margin: 20px 30px;
                }
                textarea {
                        resize: both;
                        margin: 20px 30px;
                        font-family: "Courier New", Courier, monospace;
                        /* font-family: "Lucida Console", Monaco, monospace; */
                        font-size: large;
                }
                textarea.rightAlign {
                        text-align:right;
                }
                #infoHolder {
                        margin-left: 50px;
                        margin-top: 20px;
                }
                .infoDiv {
                        margin: 10px 30px;
                        padding: 0px 10px;
                        border: 1px solid black;
                }
                .toggleButton {
                        margin: 20px;
                }
        </style>
        <script>
                class TabloidA {
                        constructor() {
                                this.n = 0; // Size of the tabloid
                                this.data = new Map(); // maps each entry from 0 to n-1 to the row in which it lies
                                // Redundant things; seems easier to store than compute each time
                                this.numRows = 0;
                                this.sh = [];
                                //Dual equivalence Data
                                this.degI = new Set();
                                // rows are sorted
                                this.rows = [];
                        }

                        static getTabloidFromString(tabloidString) {
                                let tabloid = new TabloidA();
                                let rowStrings = tabloidString.split("\n");
                                for (let rowString of rowStrings) {
                                        let rowStringArray = rowString.trim().split(" ").filter(word => word.length > 0);
                                        let row = rowStringArray.map(word => parseInt(word));
                                        row.sort(function(a, b) {
                                                return a - b;
                                        });

                                        tabloid.n += row.length;
                                        tabloid.numRows++;
                                        tabloid.sh.push(row.length);
                                        tabloid.rows.push(row);
                                        for (let elt of row) {
                                                tabloid.data.set(elt, tabloid.numRows - 1);
                                        }
                                }

                                return tabloid;
                        }

                        addRow(r) {
                                if (r.size == 0) {
                                        return;
                                }

                                this.numRows++;

                                let row = [];

                                for (let i of r) {
                                        this.data.set(i, this.numRows - 1);
                                        row.push(i);
                                }

                                this.sh.push(r.size);

                                row.sort(function(a, b) {
                                        return a - b;
                                });

                                this.rows.push(row);

                                let rowMax = row[row.length - 1];
                                this.n = Math.max(this.n, rowMax);
                        }

                        removeLastRow() {
                                if (this.numRows == 0) {
                                        throw new Error("Trying to remove row of empty tabloid.");
                                }

                                let row = this.rows.pop();
                                for (let i of row) {
                                        this.data.delete(i);
                                }

                                // if (row[row.length - 1] == this.n) {
                                //         row.pop();
                                //         row.push(0);
                                // }

                                this.numRows--;
                                this.sh.pop();
                                // let answer = new Set(row);
                                // return answer;
                                return row;
                        }

                        // getTableauA() {
                        //         let tableauA = new TableauA();
                        //         for (let i = 0; i < this.numRows; i++) {
                        //                 for (let j = 0; j < this.sh[i]; j++) {
                        //                         let tile = new Tile({x: j, y: i, n: this.rows[i][j]});
                        //                         tableauA.insertAtEnd(tile);
                        //                 }
                        //         }
                        //
                        //         return tableauA;
                        // }

                        toString() {
                                let answer = "";
                                // Figure out the column width necessary
                                let colWidth = this.n.toString().length + 1;
                                // Compose the final string
                                for (let i = 0; i < this.rows.length; i++) {
                                        for (let j = 0; j < this.rows[i].length; j++) {
                                                answer += this.rows[i][j].toString().padStart(colWidth);
                                        }

                                        answer += "\n";
                                }

                                answer = answer.slice(0, -1);
                                return answer;
                        }
                }

                class TabloidATriple {
                        /**
                         * @param {TabloidA} [left] - the left tabloid of the pair.
                         * @param {TabloidA} [right] - the right tabloid of the pair.
                         * @param {number[]} [rho] - the extra data array.
                         */
                        constructor(left, right, rho) {
                                if (!left) {
                                        /**
                                         * the left tableau of the pair
                                         * @type {TabloidA}
                                         */
                                        this.left = new TabloidA();
                                        /**
                                         * the right tableau of the pair
                                         * @type {TabloidA}
                                         */
                                        this.right = new TabloidA();
                                        /**
                                         * [rho description]
                                         * @type {number[]}
                                         */
                                        this.rho = [];
                                } else {
                                        this.left = left;
                                        this.right = right;
                                        this.rho = rho;
                                }
                        }

                        draw() {
                                document.body.appendChild(new TabloidATripleRendererDOM(this).renderDOM());
                        }

                        static AMBC(perm) {
                                let P = new TabloidA( );
                                let Q = new TabloidA( );
                                let R = [];
                                while(!perm.isEmpty()) {
                                        let nextRow = perm.forwardRSKStep();
                                        P.addRow(nextRow.r1);
                                        Q.addRow(nextRow.r2);
                                        R.push(nextRow.r);
                                }

                                return new TabloidATriple(P, Q, R);
                        }

                        static colToString(r){
                                let answer = "";
                                for (let i of r) {
                                        answer += i.toString() + "\n";
                                }

                                answer = answer.slice(0, -1);
                                return answer;
                        }

                        static parseCol(colString) {
                                let colStringArray = colString.split("\n"); //.filter(word => word.length > 0);
                                let col = colStringArray.map(word => parseInt(word));
                                return col;
                        }
                }

                class Row {
                        // public final Set<Integer> r1;
                        // public final Set<Integer> r2;
                        // public final Integer r;
                        constructor(r1, r2, r) {
                                this.r1 = r1;
                                this.r2 = r2;
                                this.r = r;
                        }
                }

                class Point{
                        constructor(xArg, yArg){
                                this.x = xArg;
                                this.y = yArg;
                        }
                }

                class ePerm {
                        constructor(input, maxJump) {
                                //Basic displayInputAndOutput
                                this.n = 0;
                                this.data = [];
                                this.isPartial = false;

                                //River theory data
                                this.swr = null; // set of integers
                                this.swrNumbering = null; // array of integers
                                this.firsts = null; // array of integers
                                this.lasts = null; // array of integers
                                this.backs = null; // Map<Integer, Point>
                                this.next = null; // Map<Integer, Integer>
                                this.backNumbering = null; // array of integers
                                this.riverX = null; // array of integers
                                this.riverY = null; // array of integers

                                if (Number.isInteger(input)) {
                                        this.n = input;

                                        let getRandomInt = function(max) {
                                                return Math.floor(Math.random() * Math.floor(max));
                                        }

                                        let preData = [];
                                        let source = [];
                                        for(let i = 1; i <= this.n; i++) {
                                                source.push(i);
                                        }

                                        for(let i = 0; i < this.n; i++) {
                                                let choiceIndex = getRandomInt(this.n - i);
                                                preData.push(source.splice(choiceIndex, 1)[0]);
                                        }

                                        for(let i = 0; i < this.n - 1; i++) {
                                                let sign = getRandomInt(2) * 2 - 1;
                                                this.data.push(preData[i] + sign * getRandomInt(maxJump) * this.n);
                                        }

                                        let total = this.n * (this.n - 1) / 2;
                                        let sum = this.data.reduce((a, b) => a + b, 0);
                                        this.data.push(total - sum);
                                        this.data.push(this.data[0] + this.n);
                                } else if (typeof input == "string") {
                                        let l = (input.replace(/\[|\]/g, "")).split(",");
                                        this.n = l.length;

                                        for (let sI of l) {
                                                this.data.push(parseInt(sI));
                                        }

                                        this.data.unshift(this.data[this.n - 1] - this.n);
                                } else { // hack to create an empty ePerm.  input == null and maxJump is the size
                                        this.n = maxJump;
                                        this.data = new Array(this.n + 1);
                                        this.data.fill(null);
                                        this.isPartial = true;
                                }
                        }

                        toString() {
                                return "[" + this.data.slice(1).toString() + "]";
                        }

                        // Clearing functions
                        clearRiver(){
                                this.swr = null;
                                this.swrNumbering = null;
                                this.firsts = null;
                                this.lasts = null;
                                this.backs = null;
                                this.next = null;
                        }

                        clearBackRiver() {
                		this.backNumbering = null;
                		this.riverX = null;
                		this.riverY = null;
                	}

                        // Correcting the mod functions
                        modn(k) {
                                return ((k % this.n) + this.n) % this.n;
                        }

                        modnOutput(k) {
                                let output = ((k % this.n) + this.n) % this.n;
                                if (output == 0) {
                                        output = this.n;
                                }

                                return output;
                        }

                        modnStrPos(k) {
                                if (k % this.n == 0) {
                                        return this.n;
                                }

                                return ((k % this.n) + this.n) % this.n;
                        }

                        modulo(k, l){
                                return ((k % l) + l) % l;
                        }

                        // Correcting the ceiling function
                        ceiling(k, l) {
                                if (k % l == 0) {
                                        return k / l;
                                }

                                return (k- ((k % l + l) % l) + l) / l;
                        }

                        isEmpty() {
                                let answer = true;
                                for (let i = 0; i < this.n; i++){
                                        if(!(this.data[i] == null)){
                                                answer = false;
                                                break;
                                        }
                                }

                                return answer;
                        }

                        isDefined(i) {
                                       return !(this.data[this.modn(i)] == null);
                        }

                        //Basic
                        get(i){
                                if(!this.isDefined(i)) {
                                        throw new Error("Attempting to access undefined ball.");
                                }

                                return this.data[this.modn(i)] + (i - this.modn(i));
                        }

                        // Backwards river theory
                	getBackNumber(k){
                		if (!this.isDefined(k)) {
                			throw new Error("Attempting to find Backward numbering of undefined ball.");
                                }

                		this.setUpRiverTheory();
                		return this.backNumbering[this.modn(k)] + (k - this.modn(k)) / this.n * this.riverX.length;
                	}

                	getBackCoordX(k){
                		// Given a row of a ball, this method gives the column of the corresponding Back River element
                		return this.riverX[this.modulo(this.getBackNumber(k), this.riverX.length)] + this.n * (this.getBackNumber(k) - this.modulo(this.getBackNumber(k), this.riverX.length)) / this.riverX.length;
                	}

                	getBackCoordY(k){
                		// Given a row of a ball, this method gives the row of the corresponding Back River element
                		return this.riverY[this.modulo(this.getBackNumber(k), this.riverX.length)] + this.n * (this.getBackNumber(k) - this.modulo(this.getBackNumber(k), this.riverX.length)) / this.riverX.length;
                	}

                        // River Theory
                        getNumber(k) {
                                if (!this.isDefined(k)) {
                                        throw new Error("Attempting to find SWR numbering of undefined ball.");
                                }

                                this.setUpRiverTheory();
                                return this.swrNumbering[this.modn(k)] + (k - this.modn(k)) / this.n * this.swr.size;
                        }

                        isLast(k) {
                                if(!this.isDefined(k))
                                        throw new Error("Attempting to access SWR numbering of undefined ball " + k + ".");
                                this.setUpRiverTheory();
                                return this.lasts.includes(k - this.n * ((this.getNumber(k) - this.modulo(this.getNumber(k), this.swr.size)) / this.swr.size));
                        }

                        getNext(k) {
                                if (!this.isDefined(k)) {
                                        throw new Error("Attempting to access SWR numbering of undefined ball.");
                                }

                                if(this.isLast(k)) {
                                        throw new Error("Attempting to access next ball after a last one.");
                                }

                                this.setUpRiverTheory();
                                return this.next.get(k - this.n * ((this.getNumber(k) - this.modulo(this.getNumber(k), this.swr.size)) / this.swr.size))
                                                + this.n * ((this.getNumber(k) - this.modulo(this.getNumber(k), this.swr.size)) / this.swr.size);
                        }

                        getBackX(k) {
                                if (!this.isDefined(k)) {
                                        throw new Error("Attempting to access SWR numbering of undefined ball.");
                                }

                                this.setUpRiverTheory();
                                return this.backs.get(k - this.n * ((this.getNumber(k) - this.modulo(this.getNumber(k), this.swr.size)) / this.swr.size)).x
                                                + this.n * ((this.getNumber(k) - this.modulo(this.getNumber(k), this.swr.size)) / this.swr.size);
                        }

                        //------------------------------
                        // Shi poset methods
                        //------------------------------

                        // Methods to determine comparability in the Shi poset
                        le(k, j) {
                                if(!this.isDefined(k) || !this.isDefined(j))
                                        throw new Error("Attempting to compare rows which are not part of the permutation");
                                return (k > j && this.data[k] < this.data[j]) || (this.data[j] - this.data[k] > this.n);
                        }

                        isComparable (i, j){
                                if(!this.isDefined(i) || !this.isDefined(j))
                                        throw new Error("Attempting to compare rows which are not part of the permutation");
                                return (i < j && this.data[i] > this.data[j]) || (i > j && this.data[i] < this.data[j]) || (Math.abs(this.data[i] - this.data[j]) > this.n);
                        }

                        // Method returning the collection of antichains of the Shi poset
                        // The antichains are given by positions of element in "data"
                        antichains() {
                                let ans = new Set();
                                ans.add(new Set()); // Add the empty set; it is always an antichain
                                let additional = new Set(); // variable to hold the newly discovered antichains
                                let additionalAC; // variable to hold a newly discovered antichain
                                // for each element of a window (note: last element of data is part of the next window so it is not used)
                                //   check whether it can be added to the previous antichains; if so then add the antichain
                                for (let i = this.data.length - 2; i >= 0; i--) {

                                        if(!this.isDefined(i))
                                                continue;
                                        acs:
                                        for(let ac of ans){
                                                for(let j of ac){
                                                        if (this.isComparable(i,j))
                                                                continue acs;
                                                }

                                                additionalAC = new Set(ac);
                                                additionalAC.add(i);
                                                additional.add(additionalAC);
                                        }

                                        // ans.addAll(additional);  see below
                                        for (let element of additional) {
                                                ans.add(element);
                                        }

                                        additional.clear();
                                }

                                return(ans);
                        }

                        // main algorithm methods
                        makeSWR() {
                                let ans = new Set();
                                let cand = new Set();
                                let antichains = this.antichains();
                                let maxSize = 0;
                                for (let ac of antichains) {
                                        maxSize = Math.max(maxSize, ac.size);
                                }

                                for (let ac of antichains ){
                                        if (ac.size == maxSize) {
                                                ans = ac;
                                                break;
                                        }
                                }

                                for (let ac of antichains) {
                                        if (ac.size < maxSize) {
                                                continue;
                                        }

                                        for (let k of ac) {
                                                for (let j of ans) {
                                                        if (this.le(k,j) || k == j) {
                                                                cand.add(k);
                                                        } else if (this.le(j,k)) {
                                                                cand.add(j);
                                                        }
                                                }
                                        }

                                        ans = cand;
                                        cand = new Set();
                                }

                                this.swr = ans;
                        }

                        makeSWRNumbering() {
                                this.swrNumbering = [];
                                for (let i = 0; i < this.n; i++) {
                                        this.swrNumbering.push(-Number.MAX_VALUE);
                                }

                                // Number the river
                                let sortedRiver = Array.from(this.swr);
                                sortedRiver.sort(function(a, b) {
                                        return a - b;
                                });

                                let count = 0;
                                for (let i of sortedRiver) {
                                        this.swrNumbering[i] = count;
                                        count++;
                                }

                                // For each ball k of the first n balls, figure out how much the others need to be shifted to be NW of it
                                // "shifts" will be a list of maps. The kth map contains j->(multiple of (n,n) by which jth ball needs to be shifted to be NW of kth ball).
                                let shifts = []; // new ArrayList<Map<Integer, Integer>>();
                                for (let k = 0; k < this.n; k++) {
                                        shifts.push(new Map()); // shifts.add(new HashMap<Integer, Integer>());
                                        if (this.swr.has(k) || !this.isDefined(k)) {
                                                continue;
                                        }

                                        // Make the original map
                                        for (let j = 0; j < this.n; j++){
                                                if (!this.isDefined(j))  {
                                                        continue;
                                                }

                                                shifts[k].set(j, Math.max(Math.max(this.ceiling(j - k, this.n) , this.ceiling((this.data[j] - this.data[k]), this.n)), 0));
                                        }

                                        shifts[k].delete(k);

                                        // Clean up the map to avoid unnecessary steps
                                        jloop:
                                        for (let j = 0; j < this.n; j++) {
                                                if(!this.isDefined(j) || j == k) {
                                                        continue;
                                                }

                                                for (let l of shifts[k].keys()) {
                                                        if ((this.data[j] - this.n * shifts[k].get(j) < this.data[l] - this.n * shifts[k].get(l)) &&
                                                                        (j - this.n * shifts[k].get(j) < l - this.n * shifts[k].get(l))) {
                                                                shifts[k].delete(j);
                                                                continue jloop;
                                                        }
                                                }
                                        }
                                }

                                // Calculate worth for the balls
                                let visited = []; //new Stack<Set<Integer>>();
                                let curY = []; // new Stack<Integer>();
                                let steps = []; // new Stack<Integer>();
                                let cY;// Integer cY;
                                let v;// Set<Integer> v;
                                let newv;// Set<Integer> newv;
                                let worth;// Integer worth;
                                let st;// Integer st;
                                let newStuff;// Set<Integer> newStuff;

                                for (let k = 0; k < this.n; k++) {
                                        if(this.swr.has(k) || !this.isDefined(k)) {
                                                continue;
                                        }

                                        worth = -Number.MAX_VALUE;
                                        curY.push(k);
                                        visited.push(new Set([k]));//visited.push(new HashSet<Integer>(Arrays.asList(k)));
                                        steps.push(0);
                                        while (curY.length > 0) {
                                                cY = curY.pop();
                                                v = visited.pop();
                                                st = steps.pop();
                                                if (this.swr.has(this.modn(cY))) {
                                                        //Calculate worth and change maximum if necessary
                                                        worth = Math.max(worth, st + this.swrNumbering[this.modn(cY)] - (this.modn(cY) - cY) / this.n * this.swr.size);
                                                } else {
                                                        //Take all the things that can be reached from cY; subtract all that were visited;
                                                        //         if something is left, push "it" onto the stacks
                                                        newStuff = new Set(shifts[this.modn(cY)].keys());
                                                        // newStuff.removeAll(v); replaced with next loop
                                                        for (let element of v) {
                                                                newStuff.delete(element);
                                                        }

                                                        for (let z of newStuff) {
                                                                curY.push(z - (this.modn(cY) - cY) - shifts[this.modn(cY)].get(z) * this.n);
                                                                newv = new Set(v);
                                                                newv.add(z);
                                                                visited.push(newv);
                                                                steps.push(st + 1);
                                                        }
                                                }
                                        }

                                        this.swrNumbering[k] = worth;
                                }
                        }

                        makeSWRBallInfo(){
                                this.firsts = []; //new ArrayList<Integer>(); // For each ball number 0<=i<swr.size() firsts will store the row of the first element
                                this.lasts = []; // new ArrayList<Integer>(); // For each ball number 0<=i<swr.size() lasts will store the row of the last element
                                this.next = new Map();// new HashMap<Integer, Integer>(); // For each row of ball numbered i, except the last one, next will store the row of the next element labeled i
                                this.backs = new Map(); // new HashMap<Integer, Point>();// For each ball number 0<=i<swr.size() backs will store purple river element
                                let ballsLabeledI; // List<Integer>
                                for (let i = 0; i < this.swr.size; i++) {
                                        // For each ball in the first n rows find the one labelled i if possible; in this case add it to the list of balls
                                        ballsLabeledI = [];
                                        for (let j = 0; j < this.n; j++) {
                                                if (!this.isDefined(j)) {
                                                        continue;
                                                }

                                                if (((i - this.swrNumbering[j]) % this.swr.size) == 0) {
                                                        ballsLabeledI.push(j + this.n * (i - this.swrNumbering[j]) / this.swr.size);
                                                }
                                        }

                                        // Arrange the list of balls labeled i in order from southwest to northeast
                                        let perm = this;
                                        let compareBalls = function(b1, b2) {
                                                if (b1 > b2 && perm.get(b1) < perm.get(b2)) {
                                                        return(-1);
                                                }

                                                if (b1 < b2 && perm.get(b1) > perm.get(b2)) {
                                                        return(1);
                                                }

                                                return (0);
                                        }

                                        ballsLabeledI.sort(compareBalls);

                                        // Fill in the first/last/next/back info
                                        this.firsts.push(ballsLabeledI[0]);
                                        this.lasts.push(ballsLabeledI[ballsLabeledI.length - 1]);
                                        for (let k = 0; k < ballsLabeledI.length - 1; k++) {
                                                this.next.set(ballsLabeledI[k], ballsLabeledI[k + 1]);
                                                this.backs.set(ballsLabeledI[k], new Point(this.get(ballsLabeledI[0]), ballsLabeledI[ballsLabeledI.length - 1])) ;
                                        }

                                        this.backs.set(ballsLabeledI[ballsLabeledI.length - 1], new Point(this.get(ballsLabeledI[0]), ballsLabeledI[ballsLabeledI.length - 1])) ;
                                }
                        }

                        setUpRiverTheory() {
                                if (this.swr == null) {
                                        this.makeSWR();
                                        this.makeSWRNumbering();
                                        this.makeSWRBallInfo();
                                }
                        }

                        forwardRSKStep() {
                                if (this.isEmpty())
                                        throw new Error("Attempting to do a forward step on an empty permutation");

                                this.setUpRiverTheory();
                                //-------------------
                                // Figure out the RSK row data
                                let r1 = new Set();
                                let r2 = new Set();
                                let r;
                                for (let i of this.firsts) {
                                        r1.add(this.modnOutput(this.get(i)));
                                        // r1.add(this.modn(this.get(i)));
                                }

                                for (let i of this.lasts) {
                                        r2.add(this.modnOutput(i));
                                        // r2.add(this.modn(i));
                                }

                                // Figure out which rows among the first n contain last (COM: i.e. northeast) elements of SW river numbering
                                let firstStripLasts = [];
                                for (let i = 1; i < this.n + 1; i++) {
                                        if (!this.isDefined(i)) {
                                                continue;
                                        }

                                        if (this.isLast(i)) {
                                                firstStripLasts.push(i);
                                        }
                                }

                                // To figure out which river we are dealing with, take the "back" of the first one of these
                                // find what place it occupies in its nxn square, as well as which nxn square it's in
                                let posInSquare = 0;
                                for (let i = 1; i < firstStripLasts.length; i++) {
                                        if (this.modnStrPos(this.getBackX(firstStripLasts[i])) < this.modnStrPos(this.getBackX(firstStripLasts[0]))) {
                                                posInSquare++;
                                        }
                                }

                                r = this.swr.size * (this.getBackX(firstStripLasts[0]) - this.modnStrPos(this.getBackX(firstStripLasts[0]))) / this.n + posInSquare;
                                //-----------------
                                // Update the permutation
                                this.isPartial = true;
                                let newData = []; // ArrayList<Integer>
                                for (let i = 0; i < this.n + 1; i++) {
                                        if (!this.isDefined(i) || this.isLast(i)) {
                                                newData.push(null);
                                        } else {
                                                newData.push(this.get(this.getNext(i)));
                                        }
                                }

                                this.data = newData;
                                this.clearRiver();
                                this.clearBackRiver();
                                //-----------------
                                // Returns the RSK data
                                return new Row(r1, r2, r);
                        }

                        //Private method which says by how many (n,n) should b2 be translated to be NW of b1
                        // b1 and b2 are Points
                	numShifts(b1, b2){
                		return Math.max(Math.max(this.ceiling(b2.x - b1.x, this.n) , this.ceiling(b2.y - b1.y, this.n)) ,0);
                	}

                        backwardRSKSetup(r) { //r is a Row
                        	// Figure out what the river is and the backward step related numbering of the balls
                        	// if(isFull())
                        	// 	throw new Error("Attempting to do a backward step on a full permutation");
                        	this.setUpRiverTheory();

                        	// Figure out the actual river
                        	this.riverY = [];
                        	this.riverX = [];
                        	// List<Integer> r1Sorted = new ArrayList<Integer>(r.r1);
                        	// for(int i = 0; i < r1Sorted.size();i++)
                        	// 	if(r1Sorted.get(i) == 0)
                        	// 		r1Sorted.set(i, n);
                        	// Collections.sort(r1Sorted);
                        	// List<Integer> r2Sorted = new ArrayList<Integer>(r.r2);
                        	// for(int i = 0; i < r2Sorted.size();i++)
                        	// 	if(r2Sorted.get(i) == 0)
                        	// 		r2Sorted.set(i, n);
                        	// Collections.sort(r2Sorted);

                                // my code passes in a sorted array
                                let r1Sorted = r.r1;
                                let r2Sorted = r.r2;
                        	for (let i = 0; i < r2Sorted.length; i++) {
                        		// Position of river
                        		// The index inside an nxn cube is modulo(r.r+i,r2Sorted.size())); the other part is to get it to correct nxn cube
                        		this.riverY.push(r2Sorted[i]);
                        		this.riverX.push(r1Sorted[this.modulo(r.r + i, r2Sorted.length)] + this.n * (r.r + i - this.modulo(r.r + i, r2Sorted.length)) / r2Sorted.length);
                        	}

                        	// Give the first n balls initial numbering
                        	this.backNumbering = [];
                        	let tmpMax;
                        	for (let i = 0; i < this.n; i++) {
                        		if (!this.isDefined(i)) {
                        			this.backNumbering.push(null);
                                        } else {
                        			tmpMax = -Number.MAX_VALUE;
                        			for (let j = 0; j < this.riverX.length; j++) {
                        				//find the number of the translate of the river element j that lies NW of ball i
                        				tmpMax = Math.max(tmpMax, j - this.riverX.length * this.numShifts(new Point(this.get(i),i), new Point(this.riverX[j], this.riverY[j])));
                        			}

                        			this.backNumbering.push(tmpMax);
                        		}
                        	}
                        	// Go through the balls; figure out if they are first with their numbering downhill order; if so, decrease the number
                        	let isFirst;
                        	let areMore;
                        	let shift;
                        	outer:
                        		while(true) {
                        			for (let i = 0; i < this.n; i++) {
                        				if (!this.isDefined(i)) {
                        					continue;
                                                        }

                        				isFirst = true;
                        				areMore = false;
                        				// Figure out if the current ball is the northwestmost or southeastmost ball with that number
                        				for (let j = 0; j < this.n; j++) {
                        					if (!this.isDefined(j) || j == i || !(((this.backNumbering[j] - this.backNumbering[i]) % this.riverX.length) == 0)) {
                        						continue;
                                                                }

                        					shift = (this.backNumbering[j] - this.backNumbering[i]) / this.riverX.length;
                        					if ((j - this.n * shift < i) && (this.get(j) - this.n * shift < this.get(i))) {
                        						isFirst = false;
                        					} else if ((j - this.n * shift > i) && (this.get(j) - this.n * shift > this.get(i))) {
                        						areMore = true;
                                                                }
                        				}
                        				//System.out.println("Checked row " + i + "; it is first with this label: " + isFirst + "; Are there more: " + areMore);
                        				// If so, decrease its numbering
                        				if (isFirst && areMore) {
                        					this.backNumbering[i] = this.backNumbering[i] - 1;
                        					continue outer;
                        				}
                        			}

                        			break;
                        		}
                        	//System.out.println(backNumbering);
                        }

                        backwardRSKStep() {
                		if (this.riverX == null) {
                			throw new Error("The backward step is not set up");
                                }


                		let ballsLabeledI = [];
                		// newData = new ArrayList<Integer>();
                                let newData = new Array(this.n);
                                newData.fill(null);

                		for (let i = 0; i < this.riverX.length; i++) {
                			// Figure out what are the new balls which arise from river label i

                			// Find all balls labeled i
                			for (let j = 0; j < this.n; j++) {
                				if (this.backNumbering[j] == null) {
                					continue;
                                                }

                				if (((this.backNumbering[j] - i) % this.riverX.length) == 0) {
                					ballsLabeledI.push(j + this.n * (i - this.backNumbering[j]) / this.riverX.length);
                				}
                			}
                			//System.out.println("Balls labeled " + i + " are located in rows " +ballsLabeledI);
                			//Sort the balls
                			ballsLabeledI.sort(function(a, b) {
                                                return a - b;
                                        });
                			//Add two fake balls representing the backward river element; one at the beginning and one at the end
                			// Generate the new balls
                			if (ballsLabeledI.length > 0) {
                				let firstBall = ballsLabeledI[0];
                				let lastBall = ballsLabeledI[ballsLabeledI.length - 1];
                				//System.out.println("The first ball labeled " + i + " is in row " + firstBall + "; X coordinate of the backing is " + getBackCoordX(firstBall));
                				newData[this.modn(lastBall)] =  this.getBackCoordX(lastBall) - (lastBall - this.modn(lastBall));
                				newData[this.modn(this.getBackCoordY(firstBall))] =  this.get(firstBall) - (this.getBackCoordY(firstBall) - this.modn(this.getBackCoordY(firstBall)));
                			} else { //TODO start here
                				if (this.riverY[i] != this.n) {
                					newData[this.riverY[i]] =  this.riverX[i];
                				} else {
                					newData[0] = this.riverX[i] - this.n;
                                                }
                			}

                			for (let j = 1; j < ballsLabeledI.length; j++) {
                				newData[this.modn(ballsLabeledI[j - 1])] =  this.get(ballsLabeledI[j]) - (ballsLabeledI[j - 1] - this.modn(ballsLabeledI[j - 1]));
                			}

                			// ballsLabeledI.clear();
                                        ballsLabeledI = [];
                		}

                		if (newData[0] == null) {
                			newData.push(null);
                		} else {
                			newData.push(newData[0] + this.n);
                                }

                		this.data = newData;
                		this.clearRiver();
                		this.clearBackRiver();
                		//System.out.println(data);
                		// If the permutation is now full, set the isPartial flag to false
                		for (let i of this.data) {
                			if (i == null) {
                				return;
                                        }
                		}

                		this.isPartial = false;
                	}
                }

                /**
                 * The Page class is responsible for processing the user input to the webpage,
                 * and for calling methods to supply the desired output.
                 * This class is used by all the algorithm pages.
                 * In many cases, differences between the pages can be handled
                 * by the inputs to the constructor, which are mostly function objects.
                 * In some cases, we need to extend the Page class.<br><br>
                 * In most of the pages, there are two ways to obtain the input parameter
                 * (randomly-generated and explicit), and two ways to display the output
                 * (all at once or step by step).
                 * Thus four functions are needed to execute these procedures,
                 * and these are input to the constructor.
                 */
                class Page {
                        /**
                         * @param {Object} table
                         * @param {string[]} table.clearList - a list of the class names of the DOM
                         * objects on the page which need to be removed when the user requests new output.
                         * @param {function} table.getDrawable - the function which,
                         * when given a parameter object, returns the output to be drawn on the page.
                         */
                        constructor(table) {
                                /**
                                 * a list of the class names of the DOM
                                 * objects on the page which need to be
                                 * removed when the user requests new output.
                                 * @type {string[]}
                                 */
                                this.clearList = table.clearList;
                                /**
                                 * in a basic page, the function which,
                                 * when given a parameter object,
                                 * returns the output to be drawn on the page.
                                 * @type {function}
                                 */
                                this.getDrawable = table.getDrawable;
                        }

                        /**
                         * This function gets the input from a textbox which expects
                         * an integer, parses, and checks the input
                         * @param {string} boxName - the id of the textbox
                         * @param {number} cutoff - the minimum allowed value of the integer
                         * @param {string} errorMessage - message to be shown in an alert box
                         * if the entry is not proper
                         * @param {boolean} [emptyOK] - if true, the box can be empty
                         * @return {number|undefined}  the value obtained from the textbox
                         *  or undefined if the box is empty and this is permitted
                         * @throws {Error}  if the entry fails
                         */
                        getIntegerFromBox(boxName, cutoff, errorMessage, emptyOK) {
                                let entry = document.getElementById(boxName).value.trim();
                                if (entry == '' && emptyOK) {
                                        return undefined;
                                }

                                let number = parseInt(entry);
                                if (isNaN(number) || number < cutoff) {
                                        alert(errorMessage);
                                        throw new Error("Bad entry in " + boxName);
                                }

                                return number;
                        }

                        /**
                         * This function calls {@link Page#getIntegerFromBox} to obtain the
                         * value from the textbox with id 'nbox'
                         */
                        getN() {
                                let message = "Please enter a positive integer in the n box.";
                                return this.getIntegerFromBox('nbox', 1, message);
                        }

                        /**
                         * This function calls {@link Page#getIntegerFromBox} to obtain the
                         * value from the box with id 'pbox'.
                         * This box may not be present on the page.
                         * When present, its use is optional.
                         */
                        getMaxJump() {
                                let message = "Please enter a non-negative integer in this box.";
                                return this.getIntegerFromBox('maxbox', 0, message);
                        }

                        /**
                         * This function gets a user-entered parameter
                         * and returns a parmeter object, using the configuration variable
                         * {@link Page#parse}.  It has a try-catch block in case the
                         * parse function does error checking.
                         * @param {string} errorMessage - the message to use to alert
                         * the user of a defect in the parameter string.
                         * @throws {Error} This function throws an error if it catches an error
                         * thrown by {@link Page#parse}.
                         */
                        getParameterFromBox() {
                                let errorMessage = "Please check your entry."
                                let entry = document.getElementById('parameterBox').value.trim();
                                try {
                                        let parameterObject = new ePerm(entry);
                                        if (parameterObject.data.length > 21) {
                                                alert("Please enter a permutation of length no more than 20.");
                                                return;
                                        }

                                        return parameterObject;
                                } catch (e) {
                                        alert(errorMessage);
                                        throw new Error("Bad input to getParameterFromBox.");
                                }
                        }

                        /**
                         * This function is triggered when the user clicks the Run button which
                         * generates a random parameter.
                         */
                        runInput() {
                                // this.clearPrevious();
                                try {
                                        let n = this.getN();
                                        let maxJump = this.getMaxJump();

                                        let parameterObject = new ePerm(n, maxJump);
                                        this.displayInputAndOutput(parameterObject);
                                } catch (e) {

                                }
                        }

                        /**
                         * This function is triggered when the user clicks the Run button which
                         * operates on a parameter string entered by the user. It calls
                         * {@link Page#getParameterFromBox} to obtain the user input required,
                         * and then calls {@link Page#displayInputAndOutput} to do the rest of the work.
                         * This function has a try-catch block, however the catch block is currently
                         * empty, as the work of alerting the user to errors is done by the
                         * function which obtains the user input.
                         */
                        runParameter() {
                                // this.clearPrevious();
                                try {
                                        let parameterObject = this.getParameterFromBox();
                                        this.displayInputAndOutput(parameterObject);
                                } catch (e) {

                                }

                        }

                        /**
                         * This function displays the output of the algorithm on the page.
                         * @param {Object} parameterObject - the parameter object which is the input
                         * to the algorithm.
                         */
                        displayInputAndOutput(parameterObject) {
                                // this.displayInfo(parameterObject);
                                // let drawable = this.getDrawable(parameterObject);
                                // drawable.draw();
                                let tabloidTriple = TabloidATriple.AMBC(parameterObject);
                                let PBox = document.getElementById("PTextArea");
                                let PString = tabloidTriple.left.toString();
                                PBox.value = PString;
                                let QBox = document.getElementById("QTextArea");
                                let QString = tabloidTriple.right.toString();
                                QBox.value = QString;
                                let RBox = document.getElementById("RTextArea");
                                let RString = TabloidATriple.colToString(tabloidTriple.rho);
                                RBox.value = RString;
                        }

                        /**
                         * This is the event handler for the keyup event in the nbox or pbox.
                         * When the Enter key is pressed, this clicks the runRandomButton.
                         * @param  {Object} event - DOM event object
                         */
                        static randomKey(event) {
                                event.preventDefault();
                                if (event.keyCode == 13) {
                                        document.getElementById("runRandomButton").click();
                                }
                        }

                        /**
                         * This is the event handler for the keyup event in the parameterBox.
                         * When the Enter key is pressed, this clicks the runParameterButton.
                         * @param  {Object} event - DOM event object
                         */
                        static parameterKey(event) {
                                event.preventDefault();
                                if (event.keyCode == 13) {
                                        document.getElementById("runParameterButton").click();
                                }
                        }

                        reverse() {
                                let PBox = document.getElementById("PTextArea");
                                let PString = PBox.value;
                                let P = TabloidA.getTabloidFromString(PString);
                                PBox.value = P.toString();
                                let QBox = document.getElementById("QTextArea");
                                let QString = QBox.value;
                                let Q = TabloidA.getTabloidFromString(QString);
                                QBox.value = Q.toString();
                                let RBox = document.getElementById("RTextArea");
                                let RString = RBox.value;
                                let R = TabloidATriple.parseCol(RString);
                                RBox.value = TabloidATriple.colToString(R);
                                let permutation = new ePerm(null, P.n);
                                while (P.numRows > 0) {
                                        let row = new Row(P.removeLastRow(), Q.removeLastRow(), R.pop());
                                        permutation.backwardRSKSetup(row);
                                        permutation.backwardRSKStep();
                                        let one = 1;
                                }

                                document.getElementById("parameterBox").value = permutation.toString();
                        }

                        static outputKey(event) {
                                event.preventDefault();
                                if (event.altKey) {
                                        if (event.keyCode == 67 || event.keyCode == 13) {
                                                document.getElementById("reverseButton").click();
                                        }
                                }
                        }

                        /**
                         * This function displays a line of text on the page.
                         * It is usually used to display the string representation
                         * of the input to the algorithm.
                         * @param {string} text - the text to display
                         */
                        static displayText(text) {
                                let wrapper = document.createElement('div');
                                wrapper.className = "comment";
                                let content = document.createTextNode(text);
                                wrapper.appendChild(content);
                                document.body.appendChild(wrapper);
                        }

                        /**
                         * This function displays the parameter
                         * and any information entered into the comment box.
                         * @param {Object} parameterObject - the parameter object which is the input
                         * to the algorithm.
                         */
                        displayInfo(parameterObject) {
                                let wrapper = document.createElement('div');
                                wrapper.className = "comment";
                                let parameterSpan = document.createElement('span');
                                parameterSpan.style.marginRight = "10px";
                                parameterSpan.innerHTML = parameterObject.toString();
                                wrapper.appendChild(parameterSpan);
                                let commentSpan = document.createElement('span');
                                commentSpan.style.marginLeft = "10px";
                                let comment = document.getElementById("commentBox").value.trim();
                                commentSpan.innerHTML= comment;
                                wrapper.appendChild(commentSpan);
                                document.body.appendChild(wrapper);
                        }

                        /**
                         * This function removes all items on the page which have the given CSS class.
                         * @param {string} className - the name of the CSS class to remove.
                         */
                        static clearItems(className) {
                                let itemList = document.getElementsByClassName(className);
                                for (let index = itemList.length - 1; index >= 0; --index) {
                                        let item = itemList[index];
                                        item.parentNode.removeChild(item);
                                }
                        }

                        /**
                         * This function removes all output from the page.
                         */
                        clearPrevious() {
                                this.clearList.forEach((type) => Page.clearItems(type));
                        }

                        /**
                         * This function removes the last item on the page which has the given CSS class.
                         * @param {string} className - the name of the CSS class to remove.
                         */
                        static clearLastItem(className) {
                                let itemList = document.getElementsByClassName(className);
                                let item = itemList[itemList.length - 1];
                                item.parentNode.removeChild(item);
                        }

                        /**
                         * This function removes the last item of each CSS class in the clear list.
                         */
                        clearLastItems() {
                                this.clearList.forEach((type) => Page.clearLastItem(type));
                        }

                        static showHide(info) {
                                let divToToggle;
                                if (typeof(info) == "string") {
                                        divToToggle = document.getElementById(info);
                                } else {
                                        divToToggle = info;
                                }

                                if (divToToggle.style.display == 'block') {
                                        divToToggle.style.display = 'none';
                                } else {
                                        divToToggle.style.display = 'block';
                                }

                        }

                        static toggleDiv(button) {
                                let text = button.innerHTML;
                                let divName = "Div";
                                if (text[0] == "H") {
                                        let newText = text.slice(5);
                                        divName = newText + divName;
                                        button.innerHTML = newText;
                                }

                                else {
                                        divName = text + divName;
                                        button.innerHTML = "Hide " + text;
                                }

                                let div = document.getElementById(divName);
                                this.showHide(div);
                        }
                }

                /**
                 * The configuration object for the webpage AMBC.html.
                 */
                const pageAMBC = new Page({
                        clearList: ['comment', 'tableauATripleRender'],
                        getDrawable: TabloidATriple.AMBC
                        });
        </script>
        <title>AMBC Algorithm in Reverse</title>
</head>
<body>
        <h3>AMBC Algorithm in Reverse
                <button type="button" class="toggleButton" onclick="Page.toggleDiv(this)">Instructions</button>
                <button type="button" class="toggleButton" onclick="Page.toggleDiv(this)">Information</button>
        </h3>
        <div class="infoDiv" id="InstructionsDiv" style="display:none">
                <p>
                        To start, you can enter an affine permutation in the textbox labelled "Permutation".&nbsp;
                        Please see the first page, <a class="pagelink" href="AMBCAlgorithm.html">AMBC Algorithm</a>, for more information about the input to this algorithm.&nbsp;
                        Enter the 1,...,n window for the permutation.&nbsp;
                        The numbers should be separated by commas, with or without spaces between the numbers, with or without square braces.&nbsp;
                        That is, you can enter 0,2,4 or 0, 2, 4 or [0,2,4] or [0, 2, 4].&nbsp;
                        Then, click the Run button to the right of the Permutation textbox, or press Enter while in the textbox.&nbsp;
                        The result of running the AMBC algorithm will appear in the three multiline textboxes below.&nbsp;
                </p>
                <p>
                        You can alter the entries in any of the textboxes, and then run AMBC in reverse.&nbsp;
                        To do that, click the button labeled Reverse.&nbsp;
                        Alternatively, you can press Alt+C or Alt+Enter when in any one of the textboxes.&nbsp;
                        The result of running AMBC in reverse will appear in the Permutation textbox.&nbsp;
                </p>
                <p>
                        Instead of starting with an affine permutation, you can enter data directly into the three textboxes.&nbsp;
                        Use the numbers 1,...,n for some n.&nbsp;
                        The numbers don't have to be in any order.&nbsp;
                        The two tableaux should have the same shape, and the column on the right should have the same length as the tableaux.&nbsp;
                </p>
        </div>
        <div class="infoDiv" id="InformationDiv" style="display:none">
                <p>
                        This is a port to JavaScript of Mike Chmutov's Java code for the Affine Matrix Ball Construction algorithm.&nbsp;
                        The original code can be found here:  <a href="https://github.com/mchmutov/AMBC" target="_blank">https://github.com/mchmutov/AMBC</a>.&nbsp;
                        The drawing code and the code to run the webpages are borrowed from the pages on my site:&nbsp; <a href="https://devragj.github.io/" target="_blank">https://devragj.github.io/</a>.&nbsp;
                        Two papers describing the Affine Matrix Ball Construction can be found at these links:&nbsp; <a href="https://arxiv.org/abs/1511.05861" target="_blank">Matrix-Ball Construction of affine Robinson-Schensted correspondence</a>, <a href="https://arxiv.org/abs/1706.00471" target="_blank">Monodromy in Kazhdan-Lusztig cells in affine type A</a>.
                </p>
                <p>
                        Please contact me at devra.johnson at verizon.net.
                </p>
        </div>
        <div id="Controls">
                <span>Permutation: <input type="text" id="parameterBox"  size="50" onkeyup="Page.parameterKey(event)"></span>
                <span><button type="button" id="runParameterButton" class = "SmallButton" onclick="pageAMBC.runParameter()">Run</button></span>
                <span><button type="button" id="reverseButton" class = "SmallButton" onclick="pageAMBC.reverse()">Reverse</button></span>
        </div>
        <div id="Output">
                <textarea id="PTextArea" rows="10" cols="20" onkeyup="Page.outputKey(event)"></textarea>
                <textarea id="QTextArea" rows="10" cols="20" onkeyup="Page.outputKey(event)"></textarea>
                <textarea id="RTextArea" class="rightAlign" rows="10" cols="2" onkeyup="Page.outputKey(event)"></textarea>
        </div>
</body>
</html>

<!-- MIT License

Copyright (c) 2018 Michael Chmutov
Copyright (c) 2016-2018 Devra Garfinkle Johnson
Copyright (c) 2016 Christian Johnson

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. -->
